{"posts":[{"title":"Hello World 2025","text":"2024 是個值得紀錄的一年2023 年末，我離開了歐洲第一大的信用卡支付解決方案公司，加入了藍色巨人的行列。 隨著 2024 年工作量的增加，自我學習的難度也呈指數級提升，甚至連之前的筆記網站也已停更一年多。這讓我不禁思考：當軟體工程師停止自我學習的同時，是否也該重新檢視自己的生活與時間分配，是不是真的有達到 Work Life Balance？ 注意力是稀缺的資源 相較於時間分配，注意力是更稀缺的資源 我想這是我 2024 年最認同的話了，每天回到家後，想要投入新技術的學習，我總得先花大約 20 分鐘看 YouTube（或漫無目的逛蝦皮）才能真正進入狀態；有時甚至會直接選擇休息。這讓我回憶起念碩士、寫論文的日子，當時我竟能整天專注地閱讀論文、融會貫通，甚至舉一反三。 一來是現在可以分心的事情實在太多了，特別又在家班後的環境，實在很難不想放空。 二來是 注意力就像肌肉一樣，是要訓練的，念碩士時教授就有講，畢業後記得要持續念書，不然到最後連話都不會說了，或許 2025 年我該嘗試固定閱讀，看看這是否能真正提升我的注意力。 不過我也覺得這與個人的學習方法和習慣有關。我個人較喜歡 Top-down 的學習方式，先了解全局概況或各章節之間的關聯，再開始動手，就像撰寫 Side Project 時總想先規劃出完美的底層架構；但也可能因此，面對短期內用不到的知識時，我的注意力反而難以集中。 總結今年年初我終於重啟了第三版的 Knowledge Management，也花了一點時間研究 ppoffice 的 icarus Hexo Template，希望在 2025 年總結時能統計一下自己達成了哪些成就，並多分享與紀錄自己的所見所聞（不僅限於技術領域），同時也堅持自己的學習初衷： 我們不需要很厲害才能開始，但一定要開始後才能很厲害","link":"/2025/02/24/Hello-World-2025/"},{"title":"H2 資料庫測試出現 JdbcSQLSyntaxErrorException","text":"情境這幾天在測試 H2 資料庫用於單元測試，寫了一個 LoginVaildation (可參考我的 Github 專案)。 其中創建了 schema.sql &amp; data.sql 用於表的創建與資料的建置。 schema.sql 12345CREATE TABLE USER ( EMAIL VARCHAR(30) PRIMARY KEY, PXSSWORD VARCHAR(12), USERNAME NVARCHAR(30)); data.sql 1INSERT INTO USER (EMAIL, PXSSWORD, USERNAME) VALUES ('willy4543@gmail.com', 'Demo1234', 'William'); 執行後報出 JdbcSQLSyntaxErrorException 1Caused by: org.h2.jdbc.JdbcSQLSyntaxErrorException: Syntax error in SQL statement &quot;CREATE TABLE [*]USER ( EMAIL VARCHAR(30) PRIMARY KEY, PASSWORD VARCHAR(12), USER_NAME NVARCHAR(30) )&quot;; expected &quot;identifier&quot;; 原因USER 在 H2 內雖然不是 Table 的保留字，但 USER 是一個保留的標誌符 (identifier)，所以 H2 資料庫會把它當作當前登錄的用戶名稱。這就會導致指令出錯，拋出錯誤訊息告知在指令中出現了無效的標誌符。 解法把 TABLE 的名稱從 USER 更改為 PROJECT_USER 即可。 有時候這種來自小小設定的問題，似乎也只在遇到的時候記得，簡單紀錄一下。","link":"/2025/02/24/JdbcSQLSyntaxErrorException/"},{"title":"JPA 複合主鍵重複情境","text":"情境說明目前 JPA 幾乎是 Hibernate 框架的主流應用，內建 ORM 功能，並支援基礎的 findById、findAll 方法。 這週在支援其他案子時遇到一個奇怪的問題：使用 JPA 取資料時，結果出現了數筆重複資料。直覺上會以為是轉換成 DTO 時重複 set 資料導致，但實際觀察發現，有些資料會重複、有些不會。進一步追查才發現問題出在：使用複合主鍵 @Id + @IdClass 的情況下，主鍵值發生了重複。 原因來自 SA 設計資料表時，誤將 txn_time 當作唯一鍵值的一部分，實際資料卻沒有保證唯一性。 在理想情況下，Table 設計中複合主鍵應該構成一組真正的 PRIMARY KEY 或 UNIQUE KEY。然而理想很豐滿，現實很骨感，特別是新舊系統交接、資料遷移（Data Migration）時，常會出現這類不一致問題。 模擬資料1234567891011121314151617181920-- 建立資料表，且不設定 primary keyCREATE TABLE TXN_LOG ( product_name NVARCHAR(255), txn_time DATETIME NOT NULL, product_type NVARCHAR(50) NOT NULL, user_ixd NVARCHAR(50) NOT NULL);-- 插入資料（包含重複主鍵值）INSERT INTO TXN_LOG (product_name, txn_time, product_type, user_ixd) VALUES(N'信用卡繳費', '2025-04-07 10:00:00', 'PAYMENT', 'user001'),(N'信用卡繳費', '2025-04-07 10:05:00', 'PAYMENT', 'user002'),(N'Netflix 訂閱(A)', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:20:00', 'TRANSFER', 'user002'),(N'Netflix 訂閱', '2025-04-07 10:25:00', 'SUBSCRIPTION', 'user003'),(N'信用卡繳費', '2025-04-07 10:30:00', 'PAYMENT', 'user004'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:40:00', 'TRANSFER', 'user001'),(N'信用卡繳費', '2025-04-07 10:45:00', 'PAYMENT', 'user003'); Entity 與複合主鍵123456789101112131415161718192021@Entity@Data@IdClass(TxnLogEntityPk.class)@Table(name = &quot;TXN_LOG&quot;)public class TxnLogEntity implements Serializable { @Column(name = &quot;product_name&quot;) private String productName; @Id @Column(name = &quot;txn_time&quot;) private LocalDateTime txnTime; @Id @Column(name = &quot;product_type&quot;) private String productType; @Id @Column(name = &quot;user_ixd&quot;) private String userIxD;} 1234567891011@Data@AllArgsConstructor@NoArgsConstructorpublic class TxnLogEntityPk implements Serializable { private LocalDateTime txnTime; private String productType; private String userIxD;} 呼叫 findAll() 取得資料12345678910111213141516@Overridepublic List&lt;TxnLogRs&gt; getTxnLogList(TxnLogRq rq) { List&lt;TxnLogRs&gt; rsList = new ArrayList&lt;&gt;(); List&lt;TxnLogEntity&gt; entityList = txnLogRepository.findAll(); for (TxnLogEntity entity : entityList) { TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(entity.getTxnTime()); rs.setProductType(entity.getProductType()); rs.setUserIxD(entity.getUserIxD()); rs.setProductName(entity.getProductName()); rsList.add(rs); } return rsList;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:00:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:05:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:20:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:25:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user003&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:30:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user004&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:40:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:45:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user003&quot; }] 你會發現重複的主鍵資料，JPA 只會保留第一筆，導致資料丟失或重複。 即使改用 JPQL 或 Native Query？12345@Query(&quot;SELECT r FROM TxnLogEntity r&quot;)List&lt;TxnLogEntity&gt; findAllTxnLogEntity();@Query(value = &quot;SELECT * FROM TXN_LOG&quot;, nativeQuery = true)List&lt;TxnLogEntity&gt; findAllTxnLogEntityWithNative(); 依然會有重複問題！ Hibernate/JPA 的底層解析Hibernate 背後維護一個 Persistence Context（即 Entity 一級快取），裡面用如下結構儲存 Entity： 1Map&lt;Serializable, Object&gt; entitiesById; 這裡的 key 就是你設定的主鍵（@Id 或 @IdClass），value 是對應的 Entity。 每當 Hibernate 從資料庫取出一筆 row，它會： 讀取主鍵組合 檢查是否已經有相同主鍵的 Entity 在快取中 有的話 -&gt; 跳過 or 覆蓋 沒有的話 -&gt; 加入 Map 所以如果主鍵欄位值重複，只會保留第一筆或最後一筆。 解法：使用 DTO 接資料若無法變更資料庫設計（或不能加上真正的主鍵/唯一鍵），最佳解法就是不用 Entity 當回傳型別，而是用自訂的 DTO 或 VO 來承接結果。 使用 JPQL constructor expression12@Query(&quot;SELECT new com.william.all_test.repository.dto.TxnLogDto(t.productName, t.txnTime, t.productType, t.userIxD) FROM TxnLogEntity t&quot;)List&lt;TxnLogDto&gt; findAllTxnLogToDto(); 接著用這些 DTO 組出回傳資料： 12345678910List&lt;TxnLogDto&gt; dtoList = txnLogRepository.findAllTxnLogToDto();for (TxnLogDto dto : dtoList) { TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(dto.getTxnTime()); rs.setProductType(dto.getProductType()); rs.setUserIxD(dto.getUserIxD()); rs.setProductName(dto.getProductName()); rsList.add(rs);} 結果就會正確地包含每一筆資料，即使主鍵值重複，也不會被覆蓋掉，因為 JPA 不會把 DTO 當成持久化實體處理，也就沒有主鍵比對與快取問題。 這類問題其實在系統設計初期就可以避免，但實務上在資料遷移、系統整併或接手舊案時，仍很容易踩到坑。 若沒遇過這種狀況，Debug 起來真的會很崩潰，尤其是一直以為是 lambda、轉 DTO、list 重複 add 導致，然後卡在那裏核對快一個小時。 剛好這次遇到，把案例記錄下來。","link":"/2025/04/08/JpaDuplicateCompositeKey/"},{"title":"從霧裡來","text":"Cue Dependence 是一種記憶理論，由認知心理學家 Endel Tulving 提出，認為記憶形成時的線索，與未來檢索記憶時有密切的關係。 這些 cues 可能是場景，情緒，氣味，聲音，或是文字提示，幫助我們重新喚起記憶。 2025/2/19，我金門土生土長的漁夫阿公在家裡壽終正寢；不像我老家隔壁的伯公，在生命最後的清晨仍在海上灑網，直至天明時被海巡撈起，浪漫且悲壯。那天起家裡便要求外傭對阿公嚴加看管，好比把膠筏上馬達的鑰匙藏起來，只怕這片的海，最終都要收回他們。 我對阿公的印象就是一個典型舊時代男性，大男人，功利主義，對金錢十分執著；他曾用木筷指著玻璃空碗對兒時的我說，你知道什麼是飯桶嗎，就是只會吃飯的人，想想真是細思極恐；而年幼的我對阿公說，我現在是小孩沒本事賺錢，但我長大後要賺錢給阿公花，他笑得合不攏嘴，直到他失智的那段時間，依然能對我侃侃而談這段往事。 所以在入殮的那時，我們把各種幣別的鈔票撲滿他的身體，多到應該會通膨的那種，不知道那頭有沒有金管會能處理這件事。 接著父親在他耳邊說出藏匿馬達鑰匙的位置，就和當年外公火化前一樣，外婆把一管黑嘉麗軟糖放進他的口袋，輕聲地對他說不要再到廚房偷冰糖吃了。 想想真是好笑，笑得我滿眼都是淚，笑得我看不清楚紙鈔上的面額。 公祭當天，我手捧著要送給阿公的海釣俱樂部，可能都一直站著的原因，黑色的運動褲在我的腰上印出像東崗海灘上的水紋，這種痛癢感讓我想起小時候清明節回去的夜晚，我抓著紅透的皮膚起床找阿嬤，但她與阿公都消失在老家裡，只好搖醒哥哥一起爬上三樓，神壇上紅通的蠟燭與高掛的吳姓燈籠，本能地讓我們逃回樓下。後來我們抽出大門的木鞘，四月的霧就這樣湧進客廳，而我們走到大街上，直到霧氣吞沒我們的哭聲。 後來阿公帶著阿嬤從海邊回來了，肩上的扁擔掛著裝滿漁獲的橘色塑膠箱。阿嬤看我哭，一邊擦拭我臉上的淚，一邊說金門風大，早上起霧，中午就會出太陽的。 而今天清晨海平面也都是霧氣，中午太陽也好大好熱，但我知道他們再也不會從霧裡出現了。","link":"/2025/03/01/fromTheFog/"},{"title":"Orcale BD ORA-01704 string literal too long","text":"情境最近在做一些網路交易系統的開發，過程中需要不斷往 DB 塞入大量的法規 html 字串，取出後在前端再用 v-html 渲染。 範例 SQL12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容&lt;/div&gt;'),); 在 INSERT 的時候 IDE ORA-01704: string literal too long 的訊息；忽然想到以前做專案的時候會在各段落間穿插 ') || TO_CLOB(' 來分段。 原因是 Oracle SQL 單一字串（VARCHAR2 literal） 最大只能 4000 bytes。而在 Oracle SQL Parser（語法解析階段）啟動時，TO_CLOB('...') 內的內容，在進入 TO_CLOB 函數之前，首先被當作 SQL String Literal 處理。所以超過 4000 bytes，Oracle 在 Parser 階段會直接報錯。 如果字串合法（≤ 4000 bytes），Oracle 才會把這個 String Literal 當成參數傳給 TO_CLOB()。 所以就改為: 12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容1 ') || TO_CLOB(' 超長的法規條款內容2 ') || TO_CLOB(' 超長的法規條款內容3&lt;/div&gt;'),); 最後乾脆讓 AI 寫一個 Main 方法，之後包在測試工具類裡面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*;public class ToClobFormatter { public static void main(String[] args) { String inputFilePath = &quot;D:/tmp/target.txt&quot;; String outputFilePath = &quot;D:/tmp/result.txt&quot;; int chunkSize = 700; // 以「字數」切段 try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFilePath), &quot;UTF-8&quot;)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFilePath), &quot;UTF-8&quot;))) { writer.write(&quot;TO_CLOB('&quot;); // 開頭先寫入 TO_CLOB int currentLength = 0; StringBuilder chunkBuffer = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { // 保留原格式與換行，單引號轉義 String processedLine = line.replace(&quot;'&quot;, &quot;''&quot;) + &quot;\\n&quot;; int linePos = 0; while (linePos &lt; processedLine.length()) { int remaining = chunkSize - currentLength; int charsToTake = Math.min(remaining, processedLine.length() - linePos); chunkBuffer.append(processedLine, linePos, linePos + charsToTake); currentLength += charsToTake; linePos += charsToTake; if (currentLength &gt;= chunkSize) { writer.write(chunkBuffer.toString()); writer.write(&quot;')||TO_CLOB('&quot;); chunkBuffer.setLength(0); // 清掉buffer currentLength = 0; } } } // 最後剩下的寫出去 if (chunkBuffer.length() &gt; 0) { writer.write(chunkBuffer.toString()); } writer.write(&quot;')&quot;); // 收尾 } catch (IOException e) { e.printStackTrace(); } }}","link":"/2025/03/24/Ora01704/"},{"title":"Colorly | 1. 整合 Spring Cloud 的微服務專案 [開發中]","text":"Colorly 是一個正在開發中的 Spring Cloud + Vue3 的微服務專案，核心服務是提供用戶上傳照片，並返回一組該照片代表色的色碼 (使用 k-means 取五組)，開發的核心 Demo 如下: 剩餘的功能則類似 pinterest, 提供 Oauth 登入, 照片探索, 上傳與蒐藏。 主要目的是重新學習一整套 Spring Cloud 的 Solutions 和其他監控平台的應用，同時記錄相關的學習歷程，產出文件；身為台灣工程師的一份子，相信大家的老闆都希望你具備手搓火箭的能力，leetcode 刷個幾百題這樣…。 目前才剛做好核心的 api, 這裡先上服務的拓樸還有順手產出的相關文件 (後續會陸續更新…)，。 前言與閒聊記得 2021 年藉著之前公司跟 Azure Spring Cloud 產品測試的機會首次接觸 Spring Cloud 模組，當時花兩周研究並一套購票系統的 Demo 做 POC, 如今隨著工作時間的增長，Spring Cloud 模組也換了好幾代，當時使用的 Zulu Gateway, Hystrix 也都廢棄了，剛好趁目前空閒的期間重新學習一套 Spring Cloud 和監控平台的整合，發佈到自己的測試機器上(測試機也是買了好幾代…)。 說到 Colorly，其前身 Color Code Tag 其實是我在 2022 年刊登在 IT鐵人賽做 做 DevOps 練習的 Side Project, 一路用 Jenkins 打包儲存 container image 在 Harbor 內，部署到 linux 上面。從當時的兩台 Dell 7040m 到現在 AM4 和 X99 雙路… 這還真是一條不歸路阿。 這次預計重學 Spring Cloud 全家餐，Jaeger/Micrometer, EFK, Prometheus Grafana 講古和閒聊就到這裡，下一篇，我們正式開始介紹架構與設計思路，而各位觀眾老爺們若有任何問題或是發現要調整的地方，歡迎私訊我與我討論及勘誤 ~~","link":"/2025/06/10/colorly-1-intro/"},{"title":"Colorly | 2. Colorly 架構介紹","text":"Colorly 是一個提供照片代表色分析的 Web 專案, 其核心功能是讓用戶上傳照片, 由程式計算該照片之代表色碼, 並提供用戶上傳, 瀏覽, 蒐藏等功能。 本專案使用 Spring Cloud 微服務架構開發, 並提供相應的觀測平台。 後面經過一些調整後, 再次補充到 Infra Layer 的圖片, 整個伺服器唯一台 windows server, 裡面藉由 vmware 搭建數台 vm 分離環境, 並由 nginx 作為 reverse proxy。 而針對 uat 環境的 vm 與服務, 以及監控的 console 則不開放外部訪問, 僅於內網中使用與測試。 選用技術前端 Vue3 + ElementPlus Nginx reverse proxy 後端 Java 17 Spring Boot 3.4.5 Spring Cloud 2024.0.1 Spring Security + Oauth2 中間件 Consul 服務發現 RabbitMq 儲存 Mysql 8 Redis MinIO Bucket 監控平台 Jaeger + Microceter Promethues + Grafana EFK 設計上包含幾個重點: 以 Consul + Spring Cloud 做微服務的基礎架構 Redis 作為 jwt 後踢前與 service cache, lazy loading 使用 RabbitMq 用於非同步事件, OutBox Pattern 和 Error Log 處理 MinIO 用於儲存照片 後面的章節，我會挑選幾個重點內容分享","link":"/2025/06/11/colorly-2-arch/"},{"title":"Colorly | 3. 專案目錄結構 (Clean Architecture)","text":"相信身為一個 main Java 的 碼儂 火箭製造者，應該都用過 Controller、Service、Repository 經典的三層架構。這好上手，分層直觀，基本上照著寫，就算是剛畢業的新人也能輕鬆把功能跑起來。 用久了也不難發現它的限制，像是 Service 越寫越肥，一個 class 打開來幾千行（還沒寫註解）, 程式過手好幾個人變成縫合怪, 維護起來壓力山大, 為了把邏輯拆出去出現各種 helper 或 utils 類別來解耦。 到後期看到某段業務邏輯拆到 helper 裡，實際上那段邏輯只會被那個 Service 用到；或者是專案裡建立 BffUtils, BizUtils，聽起來像是共用的工具，其實裡面藏了不少跟特定業務綁死的邏輯。 接著身邊不少同事開始研究 (吹捧) DDD 搭配 Clean Architecture 更有彈性, 邏輯與技術解耦, 模組之間的邊界清晰等，後續要擴充或替換元件會輕鬆很多。 剛好藉這次 Side Project 的機會來實作一下, 主要參考 Tom Hombergs 的 Clean Architecture, 其中有部分調整的地方也會特別說明。 核心概念我認為 Clean Architecture 的實作有三大概念: 依賴方向保護核心邏輯 用語意建構程式架構 責任分離與加強替換性 下面我用一個進行中的範例來呈現: 常見作法是拆成 Entity、UseCase、Controller、Presenter、Gateway 這幾層, 而這裡把 UseCase 的邏輯放進了 Domain Layer 裡的 ImageService, 然後用 port 來取代 Gateway 的概念。 主要是 UseCase 相對單純, 未來再抽出來獨立維護。 整體流程大概是： Controller 接收照片後, 會先執行一連串的驗證（格式、大小、完整性等）, 驗證通過後, 將圖片資訊封裝成事件, 透過 MQ 發送給後續服務。 其中由 port 來定義需要的操作, ImageValidator、ImageIntegrityValidator 和 MessageQueuePublisher 三個 interface。就像是 對外的合約，負責描述 ImageService 需要哪些功能，但不關心底層實作。 實作部分則由 adapter 負責, 如 RabbitMQPublisher, 把實際怎麼驗證、怎麼送 MQ 的細節寫在 infrastructure layer, 如果未來要換掉 MQ 或改用另一套驗證邏輯，只要改 adapter implements 就好。 對應到剛剛說的三個核心概念: 依賴方向保護核心邏輯ImageService 只依賴 port interface，不會碰任何技術實作。這讓核心邏輯可以在完全不依賴框架、資料庫、MQ 的情況下運作與測試，也能在未來隨時替換 adapter 而不影響主流程。 用語意建構程式架構每個元件的命名都與實際業務流程對應，ImageValidator 驗證圖片、MessageQueuePublisher 發送事件 (但好像還能再優化一下)。 責任分離與加強替換性Controller、流程邏輯、技術實作這三層之間邊界清楚，測試時也能針對單一元件做 mock，不需要啟動整個應用程式。 另外在測試方面，我是設定用 Jacoco 做測試覆蓋率檢查，重點會放在： domain service、infra repo、adapter 做 unit test controller 則用 integration test 來跑整體流程 雖然開發時常會聽到大家推崇 TDD, 不過我自己體感下來, 很多人其實不是不會寫測試, 而是測試環境根本還沒準備好。例如資料庫沒用 test container, 測資不好造、mock 太麻煩等等, 會導致測試寫起來反而拖慢節奏。 雖然這些都有相應的解法, 但這部分測試相關的心得應該會再另外整理一篇來分享。 專案目錄結構說了這麼多, 就來上主菜吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200Colorly│├─.gitignore│ pom.xml│ ├─analytic-service (略)..│ ├─auth-service│ │ pom.xml│ │ │ └─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─colorly│ │ │ └─auth│ │ │ │ AuthApplication.java│ │ │ │ │ │ │ ├─application│ │ │ │ ├─controller│ │ │ │ │ AuthController.java│ │ │ │ │ │ │ │ │ └─dto│ │ │ │ LoginRq.java│ │ │ │ LoginRs.java│ │ │ │ OauthLoginRq.java│ │ │ │ │ │ │ ├─config│ │ │ │ SecurityConfig.java│ │ │ │ │ │ │ ├─domain│ │ │ │ ├─exception│ │ │ │ │ AuthServiceException.java│ │ │ │ │ │ │ │ │ ├─model│ │ │ │ │ AuthUser.java│ │ │ │ │ │ │ │ │ └─service│ │ │ │ │ AuthService.java│ │ │ │ │ CustomOidcUserService.java│ │ │ │ │ OAuth2AuthenticationSuccessHandler.java│ │ │ │ │ │ │ │ │ └─port│ │ │ │ OutboxPublisher.java│ │ │ │ │ │ │ └─infrastructure│ │ │ ├─adapter│ │ │ │ RabbitMqOutboxPublisher.java│ │ │ │ RabbitMqPublisher.java│ │ │ │ │ │ │ ├─filter│ │ │ │ JwtAuthFilter.java│ │ │ │ │ │ │ ├─persistence│ │ │ │ ├─entity│ │ │ │ │ OutboxEvent.java│ │ │ │ │ UserCredentialEntity.java│ │ │ │ │ │ │ │ │ └─repo│ │ │ │ OutboxEventRepository.java│ │ │ │ UserCredentialsRepository.java│ │ │ │ │ │ │ └─rabbitmq│ │ │ RabbitMQConfig.java│ │ │ │ │ └─resources│ │ application-uat.yml│ │ application.yml│ │ logback-spring.xml│ │ │ └─test│ ├─java│ │ └─com│ │ └─colorly│ │ └─auth│ │ │ RedisTestContainer.java│ │ │ │ │ ├─infrastructure│ │ │ └─repo│ │ │ OutboxEventRepositoryTest.java│ │ │ UserCredentialsRepositoryTest.java│ │ │ │ │ ├─integration│ │ │ AuthControllerTest.java│ │ │ │ │ ├─redis│ │ │ RedisTest.java│ │ │ │ │ └─security│ │ BCryptTest.java│ │ JwtUtilsTest.java│ │ │ └─resources│ application.yml│ ├─color-service(略)│ ├─common(略)│ ├─gateway │ │ pom.xml│ │ │ └─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─colorly│ │ │ └─gateway│ │ │ │ GatewayApplication.java│ │ │ │ │ │ │ ├─config│ │ │ │ GatewayRouteConfig.java│ │ │ │ SecurityConfig.java│ │ │ │ │ │ │ └─infrastructure│ │ │ └─filter│ │ │ JwtGatewayFilter.java│ │ │ │ │ └─resources│ │ application-uat.yml│ │ application.yml│ │ logback-spring.xml│ │ │ └─test│ └─java│ └─com│ └─colorly├─image-service│ │ pom.xml│ │ │ └─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─colorly│ │ │ └─image│ │ │ │ ImageApplication.java│ │ │ │ │ │ │ ├─application│ │ │ │ ├─controller│ │ │ │ │ ImageController.java│ │ │ │ │ │ │ │ │ └─dto│ │ │ │ ColorsRs.java│ │ │ │ │ │ │ ├─config│ │ │ ├─domain│ │ │ │ ├─exception│ │ │ │ │ ImageServiceException.java│ │ │ │ │ │ │ │ │ ├─model│ │ │ │ │ ColorClientRq.java│ │ │ │ │ ColorClientRs.java│ │ │ │ │ ImageIntegrityResult.java│ │ │ │ │ PhotoInfoMqDto.java│ │ │ │ │ │ │ │ │ └─service│ │ │ │ │ ImageService.java│ │ │ │ │ │ │ │ │ └─port│ │ │ │ ImageIntegrityValidator.java│ │ │ │ ImageValidator.java│ │ │ │ MessageQueuePublisher.java│ │ │ │ │ │ │ └─infrastructure│ │ │ ├─adapters│ │ │ │ ImageIntegrityValidatorImpl.java│ │ │ │ ImageValidatorImpl.java│ │ │ │ RabbitMQPublisher.java│ │ │ │ │ │ │ ├─client│ │ │ │ ├─config│ │ │ │ │ FeignTracingConfig.java│ │ │ │ │ │ │ │ │ └─feign│ │ │ │ ColorServiceClient.java│ │ │ │ │ │ │ └─rabbitmq│ │ │ RabbitMQConfig.java│ │ │ │ │ └─resources│ │ application-uat.yml│ │ application.yml│ │ logback-spring.xml│ │ │ └─test│ ├─java│ │ └─com│ │ └─colorly│ │ └─image│ │ └─infrastructure│ │ └─adapters│ │ ImageValidatorTest.java│ │ │ └─resources│ application.yml│ ├─storage-service (略)│ └─user-service (略) 最後其實架構沒有什麼絕對的對或錯, 只有符不符合團隊當下的需求。 套句我教授當年吐槽我的話, 你辛辛苦苦花一堆成本搞出這些東西, 結果沒多少人用, 還不是給老闆唾棄… 當年覺得他不可理喻, 現在慢慢能理解了, 但還是超不爽的 (笑~","link":"/2025/06/19/colorly-3-pjst/"},{"title":"Colorly | 4. 軟體開發生命週期 (Software Development Life Cycle, SDLC)","text":"SDLC（Software Development Life Cycle, 軟體開發生命週期）是一個用來描述開發軟體系統的完整流程與階段的模型。 Generally 涵蓋從規劃、設計、開發、測試、部署到維護, 用於確保開發效率與產出品質。而既然說到 週期, 代表 SDLC 不再是單一流程線，而是一個持續迭代的迴圈。 而 SDLC 也有多種實作的模型, 例如 Waterfall, Agile 等。近年來, 諸多專案藉由引入 Agile 與 DevOps，能在短週期內快速釋出功能，與適應變化, 可謂是強強聯手。我在先前參與信用卡系統開發時, 也強調將 Secure 整合到 SDLC 內, 是為安全軟體發展生命週期 (SSDLC)。 今天將以 Colorly 專案為例，逐步拆解 SSDLC 各階段在實務中如何落地，從點子到產出，從理論到程式, 開發節奏與工具如下： 短迭代敏捷開發：4 天為一個 Sprint，快速實作與驗證想法 Obsidian + Kanban 插件，追蹤 logback Markdown 記錄 API 與技術規格 Mermaid 繪製 API flow、系統架構圖 Flyway 控制資料庫 schema 版本 CI/CD 自動化流程 GitHub Action + Private Runner 自動化 Lint、測試 SonarQube 掃描 shell script 部署 部署驗證與測試 功能測試 老實說我覺得這一篇應該要放在第二篇的才對, 但是跑到第 4 週我覺得才比較穩定, 而且今天的文章主要是 Top-down 介紹 SDLC 與各方面的落地, 我想等之後更趨近穩定後再針對上面的內容獨立寫幾篇銀彈好了。 前置作業 (Scrumban, Git Strategy, Pipeline)Scrumban工欲善其事, 必先利其器, Sprint 1 &amp; 2 的目標是確認專案管理的方法, 搭建 devops pipeline 並 init-project 到最小可開發的情境。 首先是用 Obsidian + Kanban 插件, 並用 tag 分化出每個卡片的分類, 每個卡片在建立的時候都要註記它的範圍與產出, 其中 #plan 的卡片在完成設計後再拆分成數個子項目。 Sprint 週期是 3 + 1, 做一次 retrospective, 目標是把 WIP 從 Design 走到 release, 最後殘留的 TODO 項目放回 Backlogs 內。 但感覺一邊研究一邊實作, Backlogs 很快就會炸開就是了… Git Strategy &amp; Pipeline由於是單人開發, 這裡是先採用 github flow, 也就是從 main 內創建 feature 分支, 在 Sprint retro 時併回 main, 並部署到 uat 環境測試。在 github actions 中設定 on-commit feature-branch 需要通過 Quality Check, (理想中) 當 Code Coverage 未通過時, 是不能被 Merge 回 Main 的, 某方面也是強迫使用 TDD。 概念上和 Will 保哥在使用的分支策略類似。 因為是孤單威廉… 就自己 review 自己吧… (不過最近有導入 AI 跟 SonarQube) Pipeline 則貫穿四個環境，分別是本地開發的 Dev (我的筆電們), github repo, devops 機(Dell 7040m), 和 sit/uat 機(一台 Am4)。並在早期就把 EFK, Jeager 等觀測元件架設好, 待後續跟 application 連結。 目前剛搭建完 uat 的環境, 等 Prod 環境完成後, 再回來更新一份完整的 Git Branch Strategy (更新中…)","link":"/2025/06/23/colorly-4-sdlc/"},{"title":"Snowflake ID 跨前後端的整數精度問題","text":"情境最近在開發一款 Pos 系統的 Side Project, 由於是走微服務架構, 所以想採用 SnowflakeID 來確保全局唯一且趨勢遞增，避免自增 ID 對分庫分表的限制。 概念如下: 1 bit 41 bits 10 bits 12 bits 符號位 時間戳(ms) 機器ID 序列號 起始時間 2025-07-22 00:00:00 UTC = 1753056000000snowflake.atacenter-id=1 # 資料中心 ID (1-2)datacenter-id: 1 # 資料中心 ID (1-2 預設台北高雄各一台)machine-id: 3 # 機器 ID (1-2 預設每個 DC 各一台 VM) 大家對實作若有興趣可以參考我沒勘誤的文件(汗…) Casha Pos 內的 Snowflake ID 結果在測試的時候踩了一個很基本的坑, 由於後端直接回傳 id 為 Long 到前端以 number 承接, 導致 13729683518521345 在瀏覽器變成 13729683518521344。 原因JavaScript 的 Number 精度限制: • JSON 在瀏覽器端預設會用原生 JSON.parse，把數字解析成 JavaScript 的 Number（IEEE-754 double）。 • Number 的「安全整數」範圍只有：-2^53 ~ 2^53（上限 9007199254740991）。 • 只要超過這個範圍，parse 時就會「四捨五入」到最近可表示的整數，導致尾數失真。 • 例：13729683518521345 &gt; 9007199254740991，所以 parse 後會被四捨五入成 13729683518521344。 解法簡單來說就是修改 Long -&gt; String, 目前有兩個做法: 第一是直接在 Bff 的 Service 內置換 dto, 第二是在 Rs 上加入 @JsonSerialize(using = ToStringSerializer.class) 但建議還是乖乖換比較好。 結論原先的專案多數用 Auto Increment, 用到不小心忽略這個細節, 果然還是要定期複習前端, 真是汗顏…","link":"/2025/08/28/snowflakeId-frontend/"}],"tags":[{"name":"chit-chat","slug":"chit-chat","link":"/tags/chit-chat/"},{"name":"develop","slug":"develop","link":"/tags/develop/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"colorly","slug":"colorly","link":"/tags/colorly/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"},{"name":"SDLC","slug":"SDLC","link":"/tags/SDLC/"},{"name":"github Actions","slug":"github-Actions","link":"/tags/github-Actions/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"}],"categories":[{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Troll","slug":"Troll","link":"/categories/Troll/"},{"name":"Development","slug":"Development","link":"/categories/Development/"}],"pages":[{"title":"關於我","text":"我是 William Wu, 曾任美商國際商業機器 Application Consultant，主要從事 Java Backend、DevOps 在台灣銀行與金融領域的開發。 Williamrightone/km-book 是我於 2022 年七月起用於紀錄學習、分享技術與 Side Project 的專案，期間經歷 GitBook, Hugo 到近期嘗試使用 Hexo，偶而會分享一些生活的心得。 除了自我學習以外，也希望能幫助到遭遇相同問題的人 我們不需要很厲害才能開始，但一定要開始後才能很厲害 不定期更新，若內容有需修正的地方也請不吝通知我~ Willy4543@gmail.com 剛出社會的時候大學同學遺忘糾露營、早期又揪不到人組團參加 It Iron-man，被戲稱 孤單威廉，另外我也是一位 Lindy Hop Dancer, 或許有一天我們會在舞池相遇。","link":"/about/index.html"}]}