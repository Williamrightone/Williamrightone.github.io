{"posts":[{"title":"Hello World 2025","text":"2024 是個值得紀錄的一年2023 年末，我離開了歐洲第一大的信用卡支付解決方案公司，加入了藍色巨人的行列。 隨著 2024 年工作量的增加，自我學習的難度也呈指數級提升，甚至連之前的筆記網站也已停更一年多。這讓我不禁思考：當軟體工程師停止自我學習的同時，是否也該重新檢視自己的生活與時間分配，是不是真的有達到 Work Life Balance？ 注意力是稀缺的資源 相較於時間分配，注意力是更稀缺的資源 我想這是我 2024 年最認同的話了，每天回到家後，想要投入新技術的學習，我總得先花大約 20 分鐘看 YouTube（或漫無目的逛蝦皮）才能真正進入狀態；有時甚至會直接選擇休息。這讓我回憶起念碩士、寫論文的日子，當時我竟能整天專注地閱讀論文、融會貫通，甚至舉一反三。 一來是現在可以分心的事情實在太多了，特別又在家班後的環境，實在很難不想放空。 二來是 注意力就像肌肉一樣，是要訓練的，念碩士時教授就有講，畢業後記得要持續念書，不然到最後連話都不會說了，或許 2025 年我該嘗試固定閱讀，看看這是否能真正提升我的注意力。 不過我也覺得這與個人的學習方法和習慣有關。我個人較喜歡 Top-down 的學習方式，先了解全局概況或各章節之間的關聯，再開始動手，就像撰寫 Side Project 時總想先規劃出完美的底層架構；但也可能因此，面對短期內用不到的知識時，我的注意力反而難以集中。 總結今年年初我終於重啟了第三版的 Knowledge Management，也花了一點時間研究 ppoffice 的 icarus Hexo Template，希望在 2025 年總結時能統計一下自己達成了哪些成就，並多分享與紀錄自己的所見所聞（不僅限於技術領域），同時也堅持自己的學習初衷： 我們不需要很厲害才能開始，但一定要開始後才能很厲害","link":"/2025/02/24/Hello-World-2025/"},{"title":"H2 資料庫測試出現 JdbcSQLSyntaxErrorException","text":"情境這幾天在測試 H2 資料庫用於單元測試，寫了一個 LoginVaildation (可參考我的 Github 專案)。 其中創建了 schema.sql &amp; data.sql 用於表的創建與資料的建置。 schema.sql 12345CREATE TABLE USER ( EMAIL VARCHAR(30) PRIMARY KEY, PXSSWORD VARCHAR(12), USERNAME NVARCHAR(30)); data.sql 1INSERT INTO USER (EMAIL, PXSSWORD, USERNAME) VALUES ('willy4543@gmail.com', 'Demo1234', 'William'); 執行後報出 JdbcSQLSyntaxErrorException 1Caused by: org.h2.jdbc.JdbcSQLSyntaxErrorException: Syntax error in SQL statement &quot;CREATE TABLE [*]USER ( EMAIL VARCHAR(30) PRIMARY KEY, PASSWORD VARCHAR(12), USER_NAME NVARCHAR(30) )&quot;; expected &quot;identifier&quot;; 原因USER 在 H2 內雖然不是 Table 的保留字，但 USER 是一個保留的標誌符 (identifier)，所以 H2 資料庫會把它當作當前登錄的用戶名稱。這就會導致指令出錯，拋出錯誤訊息告知在指令中出現了無效的標誌符。 解法把 TABLE 的名稱從 USER 更改為 PROJECT_USER 即可。 有時候這種來自小小設定的問題，似乎也只在遇到的時候記得，簡單紀錄一下。","link":"/2025/02/24/JdbcSQLSyntaxErrorException/"},{"title":"從霧裡來","text":"Cue Dependence 是一種記憶理論，由認知心理學家 Endel Tulving 提出，認為記憶形成時的線索，與未來檢索記憶時有密切的關係。 這些 cues 可能是場景，情緒，氣味，聲音，或是文字提示，幫助我們重新喚起記憶。 2025/2/19，我金門土生土長的漁夫阿公在家裡壽終正寢；不像我的伯公，在生命最後的清晨仍在海上灑網，直至天明時被海巡撈起，浪漫且悲壯。那天起家裡便對阿公嚴加看管，好比把膠筏上馬達的鑰匙藏起來，只怕這片的海，最終都要收回他們。 我對阿公的印象就是一個典型舊時代男性，大男人，功利主義，對金錢十分執著；他曾用木筷指著玻璃空碗對兒時的我說，你知道什麼是飯桶嗎，就是只會吃飯的人，想想真是細思極恐。所以在入殮的那時，我們把各種幣別的鈔票撲滿他的身體，多到應該會通膨的那種，不知道那頭有沒有金管會能處理這件事。 接著父親在他耳邊說出藏匿馬達鑰匙的位置，就和當年外公火化前一樣，外婆把一管黑嘉麗軟糖放進他的口袋，告訴他不要再到廚房偷冰糖吃了。 真是好笑，笑得我滿眼都是淚，笑得我看不清楚紙鈔上的面額。 公祭當天，可能都一直站著的原因，黑色的運動褲在我的腰上印出像海灘上的水紋，這種痛癢感讓我想起小時候清明節回去的夜晚，我抓著紅透的皮膚起床找阿嬤，但她與阿公都消失在老家裡，只好搖醒哥哥一起爬上三樓，神壇上紅通的蠟燭與高掛的吳姓燈籠，本能地讓我們逃回樓下。後來我們抽出大門的木鞘，四月的霧就這樣湧進客廳，而我們走到大街上，直到霧氣吞沒我們的哭聲。 後來阿公帶著阿嬤從海邊回來了，肩上的扁擔掛著裝滿漁獲的橘色塑膠箱。阿嬤說金門風大，早上起霧，中午就會出太陽的。 今天海平面也都是霧氣，中午太陽也好大好熱，但我知道他們再也不會從霧裡出現了。","link":"/2025/03/01/fromTheFog/"},{"title":"Orcale BD ORA-01704 string literal too long","text":"情境最近在做一些網路交易系統的開發，過程中需要不斷往 DB 塞入大量的法規 html 字串，取出後在前端再用 v-html 渲染。 範例 SQL12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容&lt;/div&gt;'),); 在 INSERT 的時候 IDE ORA-01704: string literal too long 的訊息；忽然想到以前做專案的時候會在各段落間穿插 ') || TO_CLOB(' 來分段。 原因是 Oracle SQL 單一字串（VARCHAR2 literal） 最大只能 4000 bytes。而在 Oracle SQL Parser（語法解析階段）啟動時，TO_CLOB('...') 內的內容，在進入 TO_CLOB 函數之前，首先被當作 SQL String Literal 處理。所以超過 4000 bytes，Oracle 在 Parser 階段會直接報錯。 如果字串合法（≤ 4000 bytes），Oracle 才會把這個 String Literal 當成參數傳給 TO_CLOB()。 所以就改為: 12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容1 ') || TO_CLOB(' 超長的法規條款內容2 ') || TO_CLOB(' 超長的法規條款內容3&lt;/div&gt;'),); 最後乾脆讓 AI 寫一個 Main 方法，之後包在測試工具類裡面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*;public class ToClobFormatter { public static void main(String[] args) { String inputFilePath = &quot;D:/tmp/target.txt&quot;; String outputFilePath = &quot;D:/tmp/result.txt&quot;; int chunkSize = 700; // 以「字數」切段 try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFilePath), &quot;UTF-8&quot;)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFilePath), &quot;UTF-8&quot;))) { writer.write(&quot;TO_CLOB('&quot;); // 開頭先寫入 TO_CLOB int currentLength = 0; StringBuilder chunkBuffer = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { // 保留原格式與換行，單引號轉義 String processedLine = line.replace(&quot;'&quot;, &quot;''&quot;) + &quot;\\n&quot;; int linePos = 0; while (linePos &lt; processedLine.length()) { int remaining = chunkSize - currentLength; int charsToTake = Math.min(remaining, processedLine.length() - linePos); chunkBuffer.append(processedLine, linePos, linePos + charsToTake); currentLength += charsToTake; linePos += charsToTake; if (currentLength &gt;= chunkSize) { writer.write(chunkBuffer.toString()); writer.write(&quot;')||TO_CLOB('&quot;); chunkBuffer.setLength(0); // 清掉buffer currentLength = 0; } } } // 最後剩下的寫出去 if (chunkBuffer.length() &gt; 0) { writer.write(chunkBuffer.toString()); } writer.write(&quot;')&quot;); // 收尾 } catch (IOException e) { e.printStackTrace(); } }}","link":"/2025/03/24/Ora01704/"},{"title":"JPA 複合主鍵重複情境","text":"情境目前 JPA 可以說是非常主流的 Hibernate 框架，內鍵 ORM 與基礎的 findById, findAll 方法。 這周在支援其他案子的時候碰到了一個問題，就是 JPA 取值時竟然出現了數個重複的資料，一般直覺都是 Entity 在轉換成 dto 時重複 set 資料導致，但是這個案例卻是有些重複有些沒有，仔細去看才發現是使用複合主鍵 @Id &amp; @IdClass 重複造成的。 原因在於 SA 設計表格時把 txn_time 當成唯一的鍵值。 正常情況下 Table 的設計會讓複合主鍵組成 Unique Key，然而理想很滿好現實很殘酷，尤其實在新舊系統交接 Data Migrate 的時候。 模擬資料1234567891011121314151617181920-- 建立 table, 並且不設定 pkCREATE TABLE TXN_LOG ( product_name NVARCHAR(255) , txn_time DATETIME NOT NULL, product_type NVARCHAR(50) NOT NULL, user_ixd NVARCHAR(50) NOT NULL);-- 插入資料INSERT INTO TXN_LOG (product_name, txn_time, product_type, user_ixd) VALUES(N'信用卡繳費', '2025-04-07 10:00:00', 'PAYMENT', 'user001'),(N'信用卡繳費', '2025-04-07 10:05:00', 'PAYMENT', 'user002'),(N'Netflix 訂閱(A)', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:20:00', 'TRANSFER', 'user002'),(N'Netflix 訂閱', '2025-04-07 10:25:00', 'SUBSCRIPTION', 'user003'),(N'信用卡繳費', '2025-04-07 10:30:00', 'PAYMENT', 'user004'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:40:00', 'TRANSFER', 'user001'),(N'信用卡繳費', '2025-04-07 10:45:00', 'PAYMENT', 'user003'); 同時在後端我們建立 Entity 和複合主鍵的 IdClass 12345678910111213141516171819202122@Entity@Data@IdClass(TxnLogEntityPk.class)@Table(name = &quot;TXN_LOG&quot;)public class TxnLogEntity implements Serializable { @Column(name = &quot;product_name&quot;) private String productName; @Id @Column(name = &quot;txn_time&quot;) private LocalDateTime txnTime; @Id @Column(name = &quot;product_type&quot;) private String productType; @Id @Column(name = &quot;user_ixd&quot;) private String userIxD;} 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class TxnLogEntityPk implements Serializable { private LocalDateTime txnTime; private String productType; private String userIxD;} 接著使用 JPA 預設的 findAll() 查詢 12345678910111213141516171819@Overridepublic List&lt;TxnLogRs&gt; getTxnLogList(TxnLogRq rq) { List&lt;TxnLogRs&gt; rsList = new ArrayList&lt;&gt;(); List&lt;TxnLogEntity&gt; txnLogRsList = txnLogRepository.findAll(); for(TxnLogEntity entity: txnLogRsList){ TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(entity.getTxnTime()); rs.setProductType(entity.getProductType()); rs.setUserIxD(entity.getUserIxD()); rs.setProductName(entity.getProductName()); rsList.add(rs); } return rsList;} 此時神奇的事情就發生了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:00:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:05:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:20:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:25:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user003&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:30:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user004&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:40:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:45:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user003&quot; }] 可以看到在複合主鍵相同的情境下，即便使用了 findAll()，都會將第一筆抓獲的資料覆蓋到後面相同 Id 的 Entity 上。 那如果我們把方法改成使用 JPQL 呢? 12@Query(&quot;SELECT r FROM TxnLogEntity r&quot;)List&lt;TxnLogEntity&gt; findAllTxnLogEntity(); 結果是一樣的；How about 我們再改成使用 NativeQuery ? 12@Query(value = &quot;SELECT * FROM TXN_LOG&quot;, nativeQuery = true)List&lt;TxnLogEntity&gt; findAllTxnLogEntityWithNative(); 結果也一樣會重複。 Hibernate/JPA 的底層解析Hibernate/JPA 的底層是 Persistence Context (Entity 一級快取)。 當我們呼叫了 findAll()，底層會發出 SELECT * FROM TXN_LOG，然而在下一步 Hibernate 將取得的每一筆 row 映射為 Entity 時，會針對每一筆資料，讀取它的主鍵值 (即 @Id, @IdClass 標註的欄位) 並在 Hibernate 的 EntityMap 中檢查，若該主鍵第一次出現，則加入 Persistence Context，該主鍵再次出現(雖然說資料是不一樣的)，但還是會被忽略或覆蓋舊資料。 根本原因是主鍵在 ORM 世界中，必須是唯一識別實體的依據。 Hibernate 使用主鍵值來建立內部的 Map&lt;Id, Entity&gt;，也就是： 1Map&lt;Serializable, Object&gt; entitiesById; 一個 Id 只對應一個實體物件 -&gt; 所以多筆 row 用相同主鍵，只會有一筆 survive。 解法總之就是重複的資料再丟入 Entity 時，若 Id 相同，則會導致每次都儲存第一筆 id 的資料。 如果再不能該棟資料或是調整 pk 的情境下，是不是避開使用 Entity 就好了? 這裡我們建立另一個 dto 去承接，並看看返回的結果。 12@Query(&quot;SELECT new com.william.all_test.repository.dto.TxnLogDto(t.productName, t.txnTime, t.productType, t.userIxD) FROM TxnLogEntity t&quot;)List&lt;TxnLogDto&gt; findAllTxnLogToDto(); 1234567891011List&lt;TxnLogDto&gt; txnLogRsList = txnLogRepository.findAllTxnLogToDto();for(TxnLogDto dto: txnLogRsList){ TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(dto.getTxnTime()); rs.setProductType(dto.getProductType()); rs.setUserIxD(dto.getUserIxD()); rs.setProductName(dto.getProductName()); rsList.add(rs);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:00:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:05:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;Spotify 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:20:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:25:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user003&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:30:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user004&quot; }, { &quot;productName&quot;: &quot;Spotify 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:40:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:45:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user003&quot; }] 結果正確顯示了。 雖然說這些問題在最一開始設計的時候就能避免，但是隨著專案的演進，實在不乏遇到像這樣古怪的問題與需求要解決，同時如果沒有遇過類似的情境，可能就會花很多時間在 debug 研究到底是哪個 lambda 或是迴圈在塞資料時重複塞到，今天遇到了也剛好撥空寫一些案例來測試與紀錄。","link":"/2025/04/08/JpaDuplicateCompositeKey/"}],"tags":[{"name":"chit-chat","slug":"chit-chat","link":"/tags/chit-chat/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"develop","slug":"develop","link":"/tags/develop/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Life","slug":"Life","link":"/tags/Life/"}],"categories":[{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Troll","slug":"Troll","link":"/categories/Troll/"}],"pages":[{"title":"關於我","text":"我是 William Wu, 在美商國際商業機器擔任 Application Consultant，主要從事 Java Backend、DevOps 在台灣銀行與金融領域的開發。 Williamrightone/km-book 是我於 2022 年七月起用於紀錄學習、分享技術與 Side Project 的專案，期間經歷 GitBook, Hugo 到近期嘗試使用 Hexo，偶而會分享一些生活的心得。 除了自我學習以外，也希望能幫助到遭遇相同問題的人 我們不需要很厲害才能開始，但一定要開始後才能很厲害 不定期更新，若內容有需修正的地方也請不吝通知我~ Willy4543@gmail.com 剛出社會的時候大學同學遺忘糾露營、早期又揪不到人組團參加 It Iron-man，被戲稱 孤單威廉，另外我也是一位 Lindy Hop NewComer, 或許有一天我們會在舞池相遇。","link":"/about/index.html"},{"title":"fromTheFog","text":"","link":"/fromTheFog/index.html"}]}