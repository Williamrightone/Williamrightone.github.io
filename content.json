{"posts":[{"title":"Hello World 2025","text":"2024 是個值得紀錄的一年2023 年末，我離開了歐洲第一大的信用卡支付解決方案公司，加入了藍色巨人的行列。 隨著 2024 年工作量的增加，自我學習的難度也呈指數級提升，甚至連之前的筆記網站也已停更一年多。這讓我不禁思考：當軟體工程師停止自我學習的同時，是否也該重新檢視自己的生活與時間分配，是不是真的有達到 Work Life Balance？ 注意力是稀缺的資源 相較於時間分配，注意力是更稀缺的資源 我想這是我 2024 年最認同的話了，每天回到家後，想要投入新技術的學習，我總得先花大約 20 分鐘看 YouTube（或漫無目的逛蝦皮）才能真正進入狀態；有時甚至會直接選擇休息。這讓我回憶起念碩士、寫論文的日子，當時我竟能整天專注地閱讀論文、融會貫通，甚至舉一反三。 一來是現在可以分心的事情實在太多了，特別又在家班後的環境，實在很難不想放空。 二來是 注意力就像肌肉一樣，是要訓練的，念碩士時教授就有講，畢業後記得要持續念書，不然到最後連話都不會說了，或許 2025 年我該嘗試固定閱讀，看看這是否能真正提升我的注意力。 不過我也覺得這與個人的學習方法和習慣有關。我個人較喜歡 Top-down 的學習方式，先了解全局概況或各章節之間的關聯，再開始動手，就像撰寫 Side Project 時總想先規劃出完美的底層架構；但也可能因此，面對短期內用不到的知識時，我的注意力反而難以集中。 總結今年年初我終於重啟了第三版的 Knowledge Management，也花了一點時間研究 ppoffice 的 icarus Hexo Template，希望在 2025 年總結時能統計一下自己達成了哪些成就，並多分享與紀錄自己的所見所聞（不僅限於技術領域），同時也堅持自己的學習初衷： 我們不需要很厲害才能開始，但一定要開始後才能很厲害","link":"/2025/02/24/Hello-World-2025/"},{"title":"H2 資料庫測試出現 JdbcSQLSyntaxErrorException","text":"情境這幾天在測試 H2 資料庫用於單元測試，寫了一個 LoginVaildation (可參考我的 Github 專案)。 其中創建了 schema.sql &amp; data.sql 用於表的創建與資料的建置。 schema.sql 12345CREATE TABLE USER ( EMAIL VARCHAR(30) PRIMARY KEY, PXSSWORD VARCHAR(12), USERNAME NVARCHAR(30)); data.sql 1INSERT INTO USER (EMAIL, PXSSWORD, USERNAME) VALUES ('willy4543@gmail.com', 'Demo1234', 'William'); 執行後報出 JdbcSQLSyntaxErrorException 1Caused by: org.h2.jdbc.JdbcSQLSyntaxErrorException: Syntax error in SQL statement &quot;CREATE TABLE [*]USER ( EMAIL VARCHAR(30) PRIMARY KEY, PASSWORD VARCHAR(12), USER_NAME NVARCHAR(30) )&quot;; expected &quot;identifier&quot;; 原因USER 在 H2 內雖然不是 Table 的保留字，但 USER 是一個保留的標誌符 (identifier)，所以 H2 資料庫會把它當作當前登錄的用戶名稱。這就會導致指令出錯，拋出錯誤訊息告知在指令中出現了無效的標誌符。 解法把 TABLE 的名稱從 USER 更改為 PROJECT_USER 即可。 有時候這種來自小小設定的問題，似乎也只在遇到的時候記得，簡單紀錄一下。","link":"/2025/02/24/JdbcSQLSyntaxErrorException/"},{"title":"JPA 複合主鍵重複情境","text":"情境說明目前 JPA 幾乎是 Hibernate 框架的主流應用，內建 ORM 功能，並支援基礎的 findById、findAll 方法。 這週在支援其他案子時遇到一個奇怪的問題：使用 JPA 取資料時，結果出現了數筆重複資料。直覺上會以為是轉換成 DTO 時重複 set 資料導致，但實際觀察發現，有些資料會重複、有些不會。進一步追查才發現問題出在：使用複合主鍵 @Id + @IdClass 的情況下，主鍵值發生了重複。 原因來自 SA 設計資料表時，誤將 txn_time 當作唯一鍵值的一部分，實際資料卻沒有保證唯一性。 在理想情況下，Table 設計中複合主鍵應該構成一組真正的 PRIMARY KEY 或 UNIQUE KEY。然而理想很豐滿，現實很骨感，特別是新舊系統交接、資料遷移（Data Migration）時，常會出現這類不一致問題。 模擬資料1234567891011121314151617181920-- 建立資料表，且不設定 primary keyCREATE TABLE TXN_LOG ( product_name NVARCHAR(255), txn_time DATETIME NOT NULL, product_type NVARCHAR(50) NOT NULL, user_ixd NVARCHAR(50) NOT NULL);-- 插入資料（包含重複主鍵值）INSERT INTO TXN_LOG (product_name, txn_time, product_type, user_ixd) VALUES(N'信用卡繳費', '2025-04-07 10:00:00', 'PAYMENT', 'user001'),(N'信用卡繳費', '2025-04-07 10:05:00', 'PAYMENT', 'user002'),(N'Netflix 訂閱(A)', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:20:00', 'TRANSFER', 'user002'),(N'Netflix 訂閱', '2025-04-07 10:25:00', 'SUBSCRIPTION', 'user003'),(N'信用卡繳費', '2025-04-07 10:30:00', 'PAYMENT', 'user004'),(N'Spotify 訂閱', '2025-04-07 10:10:00', 'SUBSCRIPTION', 'user001'),(N'帳戶轉帳', '2025-04-07 10:40:00', 'TRANSFER', 'user001'),(N'信用卡繳費', '2025-04-07 10:45:00', 'PAYMENT', 'user003'); Entity 與複合主鍵123456789101112131415161718192021@Entity@Data@IdClass(TxnLogEntityPk.class)@Table(name = &quot;TXN_LOG&quot;)public class TxnLogEntity implements Serializable { @Column(name = &quot;product_name&quot;) private String productName; @Id @Column(name = &quot;txn_time&quot;) private LocalDateTime txnTime; @Id @Column(name = &quot;product_type&quot;) private String productType; @Id @Column(name = &quot;user_ixd&quot;) private String userIxD;} 1234567891011@Data@AllArgsConstructor@NoArgsConstructorpublic class TxnLogEntityPk implements Serializable { private LocalDateTime txnTime; private String productType; private String userIxD;} 呼叫 findAll() 取得資料12345678910111213141516@Overridepublic List&lt;TxnLogRs&gt; getTxnLogList(TxnLogRq rq) { List&lt;TxnLogRs&gt; rsList = new ArrayList&lt;&gt;(); List&lt;TxnLogEntity&gt; entityList = txnLogRepository.findAll(); for (TxnLogEntity entity : entityList) { TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(entity.getTxnTime()); rs.setProductType(entity.getProductType()); rs.setUserIxD(entity.getUserIxD()); rs.setProductName(entity.getProductName()); rsList.add(rs); } return rsList;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:00:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:05:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:20:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user002&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:25:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user003&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:30:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user004&quot; }, { &quot;productName&quot;: &quot;Netflix 訂閱(A)&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:10:00&quot;, &quot;productType&quot;: &quot;SUBSCRIPTION&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;帳戶轉帳&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:40:00&quot;, &quot;productType&quot;: &quot;TRANSFER&quot;, &quot;userIxD&quot;: &quot;user001&quot; }, { &quot;productName&quot;: &quot;信用卡繳費&quot;, &quot;txnTime&quot;: &quot;2025-04-07T10:45:00&quot;, &quot;productType&quot;: &quot;PAYMENT&quot;, &quot;userIxD&quot;: &quot;user003&quot; }] 你會發現重複的主鍵資料，JPA 只會保留第一筆，導致資料丟失或重複。 即使改用 JPQL 或 Native Query？12345@Query(&quot;SELECT r FROM TxnLogEntity r&quot;)List&lt;TxnLogEntity&gt; findAllTxnLogEntity();@Query(value = &quot;SELECT * FROM TXN_LOG&quot;, nativeQuery = true)List&lt;TxnLogEntity&gt; findAllTxnLogEntityWithNative(); 依然會有重複問題！ Hibernate/JPA 的底層解析Hibernate 背後維護一個 Persistence Context（即 Entity 一級快取），裡面用如下結構儲存 Entity： 1Map&lt;Serializable, Object&gt; entitiesById; 這裡的 key 就是你設定的主鍵（@Id 或 @IdClass），value 是對應的 Entity。 每當 Hibernate 從資料庫取出一筆 row，它會： 讀取主鍵組合 檢查是否已經有相同主鍵的 Entity 在快取中 有的話 -&gt; 跳過 or 覆蓋 沒有的話 -&gt; 加入 Map 所以如果主鍵欄位值重複，只會保留第一筆或最後一筆。 解法：使用 DTO 接資料若無法變更資料庫設計（或不能加上真正的主鍵/唯一鍵），最佳解法就是不用 Entity 當回傳型別，而是用自訂的 DTO 或 VO 來承接結果。 使用 JPQL constructor expression12@Query(&quot;SELECT new com.william.all_test.repository.dto.TxnLogDto(t.productName, t.txnTime, t.productType, t.userIxD) FROM TxnLogEntity t&quot;)List&lt;TxnLogDto&gt; findAllTxnLogToDto(); 接著用這些 DTO 組出回傳資料： 12345678910List&lt;TxnLogDto&gt; dtoList = txnLogRepository.findAllTxnLogToDto();for (TxnLogDto dto : dtoList) { TxnLogRs rs = new TxnLogRs(); rs.setTxnTime(dto.getTxnTime()); rs.setProductType(dto.getProductType()); rs.setUserIxD(dto.getUserIxD()); rs.setProductName(dto.getProductName()); rsList.add(rs);} 結果就會正確地包含每一筆資料，即使主鍵值重複，也不會被覆蓋掉，因為 JPA 不會把 DTO 當成持久化實體處理，也就沒有主鍵比對與快取問題。 這類問題其實在系統設計初期就可以避免，但實務上在資料遷移、系統整併或接手舊案時，仍很容易踩到坑。 若沒遇過這種狀況，Debug 起來真的會很崩潰，尤其是一直以為是 lambda、轉 DTO、list 重複 add 導致，然後卡在那裏核對快一個小時。 剛好這次遇到，把案例記錄下來。","link":"/2025/04/08/JpaDuplicateCompositeKey/"},{"title":"從霧裡來","text":"Cue Dependence 是一種記憶理論，由認知心理學家 Endel Tulving 提出，認為記憶形成時的線索，與未來檢索記憶時有密切的關係。 這些 cues 可能是場景，情緒，氣味，聲音，或是文字提示，幫助我們重新喚起記憶。 2025/2/19，我金門土生土長的漁夫阿公在家裡壽終正寢；不像我的伯公，在生命最後的清晨仍在海上灑網，直至天明時被海巡撈起，浪漫且悲壯。那天起家裡便對阿公嚴加看管，好比把膠筏上馬達的鑰匙藏起來，只怕這片的海，最終都要收回他們。 我對阿公的印象就是一個典型舊時代男性，大男人，功利主義，對金錢十分執著；他曾用木筷指著玻璃空碗對兒時的我說，你知道什麼是飯桶嗎，就是只會吃飯的人，想想真是細思極恐。所以在入殮的那時，我們把各種幣別的鈔票撲滿他的身體，多到應該會通膨的那種，不知道那頭有沒有金管會能處理這件事。 接著父親在他耳邊說出藏匿馬達鑰匙的位置，就和當年外公火化前一樣，外婆把一管黑嘉麗軟糖放進他的口袋，告訴他不要再到廚房偷冰糖吃了。 真是好笑，笑得我滿眼都是淚，笑得我看不清楚紙鈔上的面額。 公祭當天，可能都一直站著的原因，黑色的運動褲在我的腰上印出像海灘上的水紋，這種痛癢感讓我想起小時候清明節回去的夜晚，我抓著紅透的皮膚起床找阿嬤，但她與阿公都消失在老家裡，只好搖醒哥哥一起爬上三樓，神壇上紅通的蠟燭與高掛的吳姓燈籠，本能地讓我們逃回樓下。後來我們抽出大門的木鞘，四月的霧就這樣湧進客廳，而我們走到大街上，直到霧氣吞沒我們的哭聲。 後來阿公帶著阿嬤從海邊回來了，肩上的扁擔掛著裝滿漁獲的橘色塑膠箱。阿嬤說金門風大，早上起霧，中午就會出太陽的。 今天海平面也都是霧氣，中午太陽也好大好熱，但我知道他們再也不會從霧裡出現了。","link":"/2025/03/01/fromTheFog/"},{"title":"Orcale BD ORA-01704 string literal too long","text":"情境最近在做一些網路交易系統的開發，過程中需要不斷往 DB 塞入大量的法規 html 字串，取出後在前端再用 v-html 渲染。 範例 SQL12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容&lt;/div&gt;'),); 在 INSERT 的時候 IDE ORA-01704: string literal too long 的訊息；忽然想到以前做專案的時候會在各段落間穿插 ') || TO_CLOB(' 來分段。 原因是 Oracle SQL 單一字串（VARCHAR2 literal） 最大只能 4000 bytes。而在 Oracle SQL Parser（語法解析階段）啟動時，TO_CLOB('...') 內的內容，在進入 TO_CLOB 函數之前，首先被當作 SQL String Literal 處理。所以超過 4000 bytes，Oracle 在 Parser 階段會直接報錯。 如果字串合法（≤ 4000 bytes），Oracle 才會把這個 String Literal 當成參數傳給 TO_CLOB()。 所以就改為: 12345678INSERT INTO DBP.CONTRACT_I18N(CONTRACT_ID, LOCALE, TITLE, CONTENT)VALUES ( 1, 'zh-TW', '數位網站&lt;br&gt;登入設施約定條款', TO_CLOB('&lt;div&gt;超長的法規條款內容1 ') || TO_CLOB(' 超長的法規條款內容2 ') || TO_CLOB(' 超長的法規條款內容3&lt;/div&gt;'),); 最後乾脆讓 AI 寫一個 Main 方法，之後包在測試工具類裡面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*;public class ToClobFormatter { public static void main(String[] args) { String inputFilePath = &quot;D:/tmp/target.txt&quot;; String outputFilePath = &quot;D:/tmp/result.txt&quot;; int chunkSize = 700; // 以「字數」切段 try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFilePath), &quot;UTF-8&quot;)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFilePath), &quot;UTF-8&quot;))) { writer.write(&quot;TO_CLOB('&quot;); // 開頭先寫入 TO_CLOB int currentLength = 0; StringBuilder chunkBuffer = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { // 保留原格式與換行，單引號轉義 String processedLine = line.replace(&quot;'&quot;, &quot;''&quot;) + &quot;\\n&quot;; int linePos = 0; while (linePos &lt; processedLine.length()) { int remaining = chunkSize - currentLength; int charsToTake = Math.min(remaining, processedLine.length() - linePos); chunkBuffer.append(processedLine, linePos, linePos + charsToTake); currentLength += charsToTake; linePos += charsToTake; if (currentLength &gt;= chunkSize) { writer.write(chunkBuffer.toString()); writer.write(&quot;')||TO_CLOB('&quot;); chunkBuffer.setLength(0); // 清掉buffer currentLength = 0; } } } // 最後剩下的寫出去 if (chunkBuffer.length() &gt; 0) { writer.write(chunkBuffer.toString()); } writer.write(&quot;')&quot;); // 收尾 } catch (IOException e) { e.printStackTrace(); } }}","link":"/2025/03/24/Ora01704/"},{"title":"Colorly | 1. 整合 Spring Cloud 的微服務專案 [開發中]","text":"Colorly 是一個正在開發中的 Spring Cloud + Vue3 的微服務專案，核心服務是提供用戶上傳照片，並返回一組該照片代表色的色碼 (使用 k-means 取五組)，開發的核心 Demo 如下: 剩餘的功能則類似 pinterest, 提供 Oauth 登入, 照片探索, 上傳與蒐藏。 主要目的是重新學習一整套 Spring Cloud 的 Solutions 和其他監控平台的應用，同時記錄相關的學習歷程，產出文件；身為台灣工程師的一份子，相信大家的老闆都希望你具備手搓火箭的能力，leetcode 刷個幾百題這樣…。 目前才剛做好核心的 api, 這裡先上服務的拓樸還有順手產出的相關文件 (後續會陸續更新…)，。 前言與閒聊記得 2021 年藉著之前公司跟 Azure Spring Cloud 產品測試的機會首次接觸 Spring Cloud 模組，當時花兩周研究並一套購票系統的 Demo 做 POC, 如今隨著工作時間的增長，Spring Cloud 模組也換了好幾代，當時使用的 Zulu Gateway, Hystrix 也都廢棄了，剛好趁目前空閒的期間重新學習一套 Spring Cloud 和監控平台的整合，發佈到自己的測試機器上(測試機也是買了好幾代…)。 說到 Colorly，其前身 Color Code Tag 其實是我在 2022 年刊登在 IT鐵人賽做 做 DevOps 練習的 Side Project, 一路用 Jenkins 打包儲存 container image 在 Harbor 內，部署到 linux 上面。從當時的兩台 Dell 7040m 到現在 AM4 和 X99 雙路… 這還真是一條不歸路阿。 這次預計重學 Spring Cloud 全家餐，Jaeger/Micrometer, EFK, Prometheus Grafana 講古和閒聊就到這裡，下一篇，我們正式開始介紹架構與設計思路，而各位觀眾老爺們若有任何問題或是發現要調整的地方，歡迎私訊我與我討論及勘誤 ~~","link":"/2025/06/10/colorly-1-intro/"},{"title":"Colorly | 2. Colorly 架構介紹","text":"Colorly 是一個提供照片代表色分析的 Web 專案, 其核心功能是讓用戶上傳照片, 由程式計算該照片之代表色碼, 並提供用戶上傳, 瀏覽, 蒐藏等功能。 本專案使用 Spring Cloud 微服務架構開發, 並提供相應的觀測平台。 選用技術前端 Vue3 + ElementPlus 後端 Java 17 Spring Boot 3.4.5 Spring Cloud 2024.0.1 Spring Security + Oauth2 中間件 Consul 服務發現 RabbitMq 儲存 Mysql 8 Redis MinIO Bucket 監控平台 Jaeger + Microceter Promethues + Grafana EFK 後面的章節，我會挑選幾個重點內容分享","link":"/2025/06/11/colorly-2-arch/"}],"tags":[{"name":"chit-chat","slug":"chit-chat","link":"/tags/chit-chat/"},{"name":"develop","slug":"develop","link":"/tags/develop/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"colorly","slug":"colorly","link":"/tags/colorly/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"}],"categories":[{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Troll","slug":"Troll","link":"/categories/Troll/"},{"name":"Development","slug":"Development","link":"/categories/Development/"}],"pages":[{"title":"關於我","text":"我是 William Wu, 曾任美商國際商業機器 Application Consultant，主要從事 Java Backend、DevOps 在台灣銀行與金融領域的開發。 Williamrightone/km-book 是我於 2022 年七月起用於紀錄學習、分享技術與 Side Project 的專案，期間經歷 GitBook, Hugo 到近期嘗試使用 Hexo，偶而會分享一些生活的心得。 除了自我學習以外，也希望能幫助到遭遇相同問題的人 我們不需要很厲害才能開始，但一定要開始後才能很厲害 不定期更新，若內容有需修正的地方也請不吝通知我~ Willy4543@gmail.com 剛出社會的時候大學同學遺忘糾露營、早期又揪不到人組團參加 It Iron-man，被戲稱 孤單威廉，另外我也是一位 Lindy Hop Dancer, 或許有一天我們會在舞池相遇。","link":"/about/index.html"}]}